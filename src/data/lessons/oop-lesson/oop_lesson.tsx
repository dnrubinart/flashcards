const oop_data = {
  lessonTitle: "Object-Oriented Programming",
  slug: "modules-oop",
  units: [
    {
      title: "Object-Oriented Programming",
      slug: "oop",
      items: [
        {
          frontSide:
            "Какво е OOP? Какво представляват класовете, инстанциите и обектите?",
          backSide:
            "Обектно-ориентираното програмиране е програмен подход, който се базира на концепцията за обекти. Обектите са инстанции на класове, които съдържат свойства (атрибути) и поведение (методи). Позволява създаването на модулни, преизползваеми и лесно поддържаеми програми.",
        },
        {
          frontSide:
            "Как можем да създадем клас, който има определено състояние и/или поведение?",
          backSide:
            "Когато създаваме клас в Python, можем да дефинираме атрибути, които представят състоянието на обектите от този клас, както и методи, които дефинират поведението на тези обекти. Self се отнася до текущата истанция на този клас.",
        },
        {
          frontSide:
            "Сравнете атрибутите на ниво клас и атрибутите на ниво инстанция.",
          backSide:
            "Класовите атрибути са свързани със самия клас, а не с инстанциите на този клас. Те се дефинират вътре в класа, но извън методите. Класовите атрибути са общи за всички инстанции на класа и се споделят между тях. Променянето на стойността на класов атрибут ще го промени за всички инстанции на класа и за самия клас.",
        },
        {
          frontSide: "Какви са магическите методи?",
          backSide:
            "Отбелязват се с double underscore. Тези методи се извикват от класа при извършване на определени операции с обекти на класове. Позволяват контрол върху поведението на обектите.",
        },
        {
          frontSide: "Сравнете mutable и immutable обекти.",
          backSide:
            "Mutable –> променяме самия обект(пример list.append), нова стойност, същото id. Immutable –> не може да бъде променян(пример int=5, int += 1, не променя int=5, а се създава нов обект int=6) -> не променя стойността, създава нов обект с ново id.",
        },
        {
          frontSide: "Какви са ползите от използването на Type Hints?",
          backSide:
            "Предоставят информация за какъв тип данни трябва да очакваме в дадена част на програмата, което помага за по-добра документация на кода и по-лесно намиране на грешки, ако има такива, защото знаем каква стойност се очаква.",
        },
        {
          frontSide: "Какво е инкапсулация? Каква е нейната цел?",
          backSide:
            "Чрез класове групираме данни(атрибути и методи). Можем да правим промени без да засягаме външната част от кода. Вътрешното им състояние се скрива от клиентската страна и тя успява да достигне само най-нужните функции. Означават се с underscore.",
        },
        {
          frontSide: "Какво е property?",
          backSide:
            "Основната цел на property е да инкапсулират достъпа до атрибутите. Помагат за валидации, изчисления и други операции, когато достъпваме, задаваме или изтриваме атрибут. Getter –> извличаме стойността и го достъпваме всеки път като извикаме property-то. Setter –> отговорен е за задаването на стойността на property. Извиква всеки път, когато property-то получи нова стойност.",
        },
        {
          frontSide: "Как можем да осигурим валидното състояние на инстанция?",
          backSide:
            "С конструктура, за да ги инициализираме с валидни стойности, да използваме декоратори или да създадем метод за валидиране.",
        },
        {
          frontSide: "Как можем да декларираме read-only property?",
          backSide:
            "Използваме само getter, за да подсигурим, че може да достъпваме property-то, но не и да го променяме.",
        },
        {
          frontSide: "Какво е наследяване? Каква е неговата цел?",
          backSide:
            "Един клас(подклас) може да наследи атрибути и методи от друг клас(родителски или базов). Това става като посочим родителския клас в скоби. Създава се йерархия на класовете, къде подкласовете разширяват функционалността на родителския клас. Преизползва се код и тези класове имат IS-A relationship.",
        },
        {
          frontSide: "Какво е полиморфизъм? Каква е неговата цел?",
          backSide:
            "Позволява да се използва един и същ метод на родителския клас от различни подкласове като го модифицираме според нуждите на класа. Постига се чрез overriding на метода.",
        },
        {
          frontSide: "Какво е абстракция? Каква е нейната цел?",
          backSide:
            "Абстракцията е концепция в програмирането, която позволява скриването на сложността на един обект и предоставя само съществените и важни характеристики и операции, които са от значение за външния свят. Отговаря на въпроса какво прави нещо, а не как се прави.",
        },
        {
          frontSide: "Каква е целта на super().__init__()?",
          backSide:
            "Извиква конструктура от главния клас в конструктура на подкласа. Подсигурява поведението на наследените атрибути и промотира преизползването на вече разписан код.",
        },
        {
          frontSide: "Как можем да override-нем наследен метод?",
          backSide:
            "Чрез полиморфизъм(нещо, което има много форми).",
        },
        {
          frontSide: "Как можем да override-нем наследено property?",
          backSide:
            "След като го наследим чрез super().__init__(), можем да override-нем getter-a и setter-a, за да го модифицираме според това, което ни е нужно в подкласа. Например различна проверка в setter-a. Това не променя property-то в главния клас.",
        },
        {
          frontSide: "Какво е Duck Typing? Сравнете със Static Typing.",
          backSide:
            "Duck Typing определя типа на обект според неговото поведение, а не според явно дефинирания му тип, и се проверява по време на изпълнение. Тя осигурява по-голяма гъвкавост и по-кратък код, но може да доведе до грешки по време на изпълнение. Static осигурява по-голяма сигурност и ранно откриване на грешки чрез явно дефинирани типове, но може да бъде по-ограничителна и да изисква повече анотации за типовете.",
        },
        {
          frontSide: "Как постигаме множествено наследяване в Python? Какви са ползите?",
          backSide:
            "В скобите наследяваме два класа. Можем да наследяваме атрибути и методи и от двата класа. Използват се главно при mixins, когато искаме да пренесем специфична функционалност в даден подклас.",
        },
        {
          frontSide: "Кога да избягваме множествено наследяване?",
          backSide:
            "Възможност да създаде диамантен проблем. Тогава подкласът наследява само първия клас. Може да направи кода по-труден за четене за незапознати с йерархията на класовете.",
        },
        {
          frontSide: "Какво представлява Method Resolution Order (MRO) на клас в Python?",
          backSide:
            "Той е важен за определяне на кой метод или атрибут ще бъде извикан, когато се извикат върху инстанция на клас, който наследява от няколко родителски класа.",
        },
        {
          frontSide: "Как постигаме композиция?",
          backSide:
            "Вместо да създаваме един голям клас, създаваме малки класове, които представляват отделни части от функционалността, която искаме да има в крайния обект. След това създаваме основния обект, който съдържа инстанции на тези малки класове като свои атрибути.",
        },
      ],
    },
  ],
};

export default oop_data;